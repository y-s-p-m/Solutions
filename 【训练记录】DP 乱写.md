# exp

设 $f_{l,r}$ 表示区间里面除了 $r$ 都变成 $X$ 的期望步数，$g_{l,r}$ 表示最后一个变化是 $r$ 的概率，$p_{l,r,k}$ 表示最后一个变化的是 $r$，倒数第二个变化是 $k$ 的概率

不难发现 $g_{l,r}=\sum_{i=l}^{r-1} p_{l,r,k}$，如果断环成链，最后答案就可以写作 $\sum_{i=1}^{n}[s[i]=X]f_{i,i+n-1}\times g_{i,i+n-1}+\frac{n-1}2$，后面附加的变量是最后一步的期望长度

整个思想就是枚举最后变成 $X$ 的位置转化作子问题那么 $p$ 的转移就可以划成 $[l,k],[l+1,r]$ 两个子问题，记左边 $.$ 的个数为 $lc$，右边 $rc$ 写作：

$$p_{l,r,k}=\binom{lc+rc}{lc}g_{l,k}\times g_{k+1,r}\times \left(\frac{k-l}{r-l+1}\right)^{lc+rc+1}\left(\frac{r-k}{r-l+1}\right)^{rc}\left(\frac{k-l+1}{r-l+1}\right)$$

使用 $\frac{len}{r-l+1}$ 表示把操作分到左边/右边的概率，再用 $\rm g_{lef/rig}$ 来限制不出现 $r$ 被选过了的概率

$f_{l,r}$ 是个期望的加权平均，所以转移式子写作

$$f_{l,r}=\frac{1}{g_{l,r}}\sum_{i=l}^{r-1}p(l,r,i)\left(f_{l,k}\times f_{k+1,r}+\frac{i-l}2\right)$$

使用记忆化搜索实现即可


# UOJ514

操作序列按照猎人杀的方式转化为求解 $\ge A$ 的期望个数，同理未充满元素被点中一次的期望次数是 $\frac n {num}$

答案可以表示为 $n\times($ $1$ 号元素在其它元素被冲到 $B$ 之前被冲到 $A$ 的概率 $)$

省略非 $1$ 元素在冲到 $B$ 之后的操作，那么剩下的序列长度为 $(n-1)b+a$，再次反向统计，试计算对 $1$ 的操作在最后一个的概率

设其它元素不再在操作序列中出现的时间为 $t_2\dots t_n$，排序后记作 $t_1,\dots t_{n-1}$ 那么概率可以被表示为

$$\frac{\prod_{i=1}^{n-1}\binom {t_i-1-(i-1)b}{b-1}}{\prod_{i=1}^{n-1}(n-i+1)^{t_i-t_{t-1}}}$$

上面组合数表示的就是钦定最后一个为操作 $p_{i}$ 之后剩下的 $(b-1)$ 次操作在没有被选中的位置里面选择的方案

由于 $p_i$ 是不定的，最后要附加 $(n-1)!$ 的权值

设 $f_{i,j}$ 表示考虑到了长度为 $i$ 的序列，不会再在操作序列里面出现的元素个数为 $j$ 的方案数，转移考虑第 $i$ 个位置是否为第 $j+1$ 的停止点，并把分母拆开逐个乘即可

$$\begin{aligned}f_{i+1,j}&\leftarrow \frac{f_{i,j}}{n-j}\\
f_{i+1,j+1}&\leftarrow\frac{f_{i,j}}{n-j}\times\binom{i-bj}{b-1} 
\end{aligned}$$

复杂度 $\Theta(n^2a)$

另有一个容斥做法是计算在 $1$ 被充满时有几个元素没有被充满，和式变换还是很复杂的，降 $\log$ 的做法甚至也只有 EI 能想到吧

# LOJ6402

考察一个连通块产生边界的条件是这段的最大值小于上一段的最小值且这段最小值大于上一段最大值

考虑 $f_i$ 表示 $i$ 个数字形成一段的方案数， $g_i$ 表示答案，转移分别是：

$$\begin{aligned}g_i&=\sum_{j=0}^{i=1}g_jf_{i-j}\\
f_i&=i!-\sum_{j=1}^{i-1}(i-j)!f_{j}\\
\end{aligned}$$

底下的式子表示容斥段数不为 $1$ 的情况，上面式子的理解是每次将 $g_{j}$ 的数字增加 $i-j$，并将 $1\sim(i-j)$ 放到序列的末尾

这里 $f$ 的转移不包含 $f_{0}$，但是它的值为 $1$

看起来非常可以 $\rm cdq\ NTT$ 但是复杂度不对，那么尝试推成多项式求逆的版本就可以了，设 $A(x)=\sum_{i=0}^{+\infty}(i!)x^i$：

$$\begin{aligned} n!&=\sum_{i=1}^n f_i(n-i)!\\
(2n)!&=\sum_{i=0}^n f_i(n-i)!+[n=0]\\
2A(x)&=F(x)A(x)+1\\
F(x)&=\frac{2A(x)-1}{A(x)}
\end{aligned}$$

这个 $g$ 的方程也可以用一样的方式得到，而且更简单，直接就是 $G(x)=\frac{1}{1-F(x)}$

时间复杂度 $\Theta(n\log n)$

# LOJ6289

平方算法是平凡的，$\rm poly \log$ 是简单优化

考虑 $\rm DSU\ on\ Tree$ 的思想，减少多项式次数和就是对降低复杂度的最大贡献

每个点执行以下流程：

- 递归计算轻儿子 $\rm DP$ 值，使用分治乘法合并，对于 表示选择该点的多项式进行平移，即加入该点贡献

- 递归计算重儿子 $\rm DP$ 值

- 判断是不是重链链顶，如果是执行重链的分治乘法，在分治过程中维护 $\rm g[p][0/1][0/1]$ 表示区间左、右端点是不是被选中了，找合法的多项式卷起来贡献

做完这题我也不敢做跳蚤国王下江南，比这题高明不知道到哪里去了

# CF1615F

如果能想到第一步就会怎么怎么着，可惜没有如果

将两个字符串中偶数位的数字取反之后，原题中连续两个相同字符取反的操作就变成了交换相邻两位！

非常奇怪但是很正确，就是乱编不出来，至此如果操作后的两个串能通过交换变成同一个串，条件就是 $0,1$ 个数相同，而最小次数就是相同排位的 $1$ 的位置的差的绝对值

计算总数考虑分成两个位置 $i,j$ 是同排位 $1$ 的方案数乘距离求和，直接 $\rm dp$ 看起来要记录是第几个 $1$，复杂度很大

关注到这等价于前面有相同数目个 $1$，后面也有相同数目个 $1$，$\rm dp$ 时就不用关心究竟是第几个 $1$，所以这维就被省去了

设 dp[i][j] 表示 $s$ 中第 $i$ 位的 $1$ 和 $t$ 中第 $j$ 位的 $1$ 是同位 $1$，那么每个 dp 值的贡献形式是一个二维矩形加，使用二维差分即可

博主又不会二维差分了/kk

# 2021-03-29 小球

先控一下 $m$ 到 $\log n$，球多了可以直接二分

考虑 $f_{l,r,k}$ 表示区间里面有 $k$ 个小球的最小步数

转移这个小球的位置，两边取 $\max$ 再取 $\min$

优化首先考虑区间位置可以忽略，那么状态转成 $f_{len,k}$，转移就是枚举两边的区间长度

值得指出的是，转移左侧的时候并不需要减少小球的个数

转换一种相对简单的做法：$dp[i][j]$ 表示 $i$ 个球 $j$ 次能得到的最大长度

转移是 $dp_{i,j}=dp_{i,j-1}+dp_{i-1,j-1}+1$ 也就是从左边或者右边来

最后枚举一下找到第一个 $dp[m][j]$ 大于 $n$ 的 $j$ 即可

考虑上式的组合意义，如果将 $g_{i,j}$ 视作图上的一个点，那么可以每个点的 $dp$ 值是往下走的方案数

# 超级树

设 $f_{i,j}$ 为 $i$ 级超级树，$j$ 条路径互不相交的方案数，这里的路径如果方向不一样也算不同的方案，比如 $1\to 2 \neq 2\to 1$

转移分为以下：

- $f_{i+1,j+k}+=f_{i,j}\times f_{i,k}$ 从左边选择 $j$ 条，右边选择 $k$ 条，不进行更新

- $f_{i+1,j+k-1}+=f_{i,j}\times f_{i,k}\times 2\times j\times k$ 合并路径


- $f_{i+1,j+k}+=f_{i,j}\times f_{i,k} \times 2\times(j+k)$  起点或者终点连到根上面

	因为想咋走就可以随便从上面走下来或者走上去

- $f_{i+1,k+j-1}+=f_{i,j}\times f_{i,k}\times (j\times (j-1)+(k-1)\times k)$ 直接在子树里面走


- $f_ {i+1,j+k+1}+=f_{i,j}\times f_{i,k} $ 添加多出来的根节点

	这个部分真的很容易漏掉！！

初始状态 $f_{1,0}=f_{1,1}=1,ans=f_{n,1}$

# Luogu4707

先记录 $\rm kth \ \min-\max$ 容斥公式：

$$\rm kthmax(S)=\sum_{T\subset S} (-1)^{|T|-k}\binom {|T|-1}{k-1}\min(T)$$

注意最后是 $\min(T)$ 而不是 $\rm kthmin(T)$ 状物，这样子才可能进行容斥系数的配凑

验证公式正确性的过程不再赘述，这个公式的得到是 $\rm kthmax(S)=\sum\limits_{T\subset S} F(T)\min(T)$ 之后考察每个元素的计算个数并使用二项式反演得到的

有读者说让我更证明，没写的原因是我有个地方的 $\pm 1$ 推的有点问题，如果以后有再推一次的机会并推得我自己认为没问题了会来简单更新的，但是这个证明确实很容易，你也可以自己写一些式子图一乐

这个过程就是最正规的容斥系数的构造，稍比二项式反演的形式复杂些

现在要求的就是若干 $\min(T)$，这个值就是 $\frac{m}{\sum\limits_{i\in T} p_i}$

那么最基础的 $\rm DP$ 就是 $f_{i,j,k}$ 表示前 $i$ 个选 $j$ 个同时 $\sum p=k$ 的方案数，最后附加上系数贡献给答案即可 

优化很没有头绪，正确做法是记录在第三维 $k$ 记录以当前的 $k$ 为基准时 $(-1)^{|T|-k}\binom {|T|-1}{k-1}$ 的值，这样子是可以转移的；

如果不选的话直接继承 $f_{i,j,k}=f_{i-1,j,k}$

选择产生了 $k$ 的增加（由于式子写作了 $\rm kthmax$ 那么这个维度上限 $n-k+1=11$）：

$$\begin{aligned}&\sum (-1)^{|T|-k}\binom {|T|-1}{k-1}\\
&=\sum (-1)^{|T|-k+1}\binom{|T|}{k-1}\\
&=\sum (-1)^{|T|-k+1}\binom{|T|-1}{k-1}+\sum (-1)^{|T|-(k-1)}\binom{|T|-1}{(k-1)-1}
\end{aligned}$$

中间一步是将这个元素删取，考虑前 $i-1$ 个物品所形成的局面，推到这里分别找到了 $-f_{i-1,j-1,k}$ 和 $f_{i-1,j-1,k-1}$ 所以剩下的就是一个背包的过程了！ 