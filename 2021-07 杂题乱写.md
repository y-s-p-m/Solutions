# CF1543E

构造妙妙题

第一问貌似直接能得到每个点到 $0$ 的距离，给 $0$ 连出去的边一个 $2^x$ 的权值，剩下的权值由相邻点扩展即可

第二问看半天能得到 $\rm{n}$ 得是 $2^n$ 的因数，否则连颜色都分不全，直接无解

剩下部分的构造考虑 $c_x=\rm{xor_{i=0}^{n-1} b_{x,i}\times i}$，然后按照上面的序列放到对应位置

确实是构造题的脑量，非常不一般，考虑其正确性

对于一个点 $x$ 颜色是 $c_x$，如果走到另一个颜色是 $c_y$ 的点 $y$，此时必然有 $y=x\ \rm{xor}\  2^{c_x-c_y}$

# ABC209E

不会做的 $\rm{ABC}$ 越来越多了诶

不难通过各种方式把图建出来，但是这里值得提醒的一点的字符集大小的三次方是个合法的数

而这个题目可以 **把边反过来** 然后直接按照 $\rm{SG}$ 函数那样子拓扑实现 $dp$ 就可以了

实际上可能只有我对着有向图想了半天怎么找环

# ABC208F

不难发现式子可以用组合数表示，那么如果全部逼到最后一列上面的话，每个点都只能往下走

那么归纳假设 $f(n,m)$ 是关于 $n$ 的 $m+k$ 次多项式，$f(n,m+1)=\sum_{i=1}^m f(n,k)$

这样子直接写一个 $Lagrange$ 插值就行了，注意预处理点值的时候要暴力 $\rm{DP}$

# CF1119G

不难证明答案的下界是 $\lceil\frac{\sum hp}{n}\rceil$，那么如何构造得到这个值呢？

比较基础的想法减少浪费掉的部分，那么考虑差分之后前缀和可能有精确求和的效果

如果那么如果把所有敌人的生命做前缀和，然后把前缀和 $\%n$ 的排序之后冲差分，把得到的数组作为每个组的人数

剩下的就是一个模拟了，不可不说是非常有意思的题目

# CF1540D

题目的 $\Theta(nq)$ 的做法如下：

```cpp
for(int i=x;i<=n;++i) if(now>=b[i]) ++now;
```

如果把 $x,n$ 的边界都变成一个区间 $[l,r]$，能给 $now$ 贡献的是哪些呢？

这个问题和分成左右两个子问题和合并的过程，那么对于右边的一个元素，权值要减掉左边小于其的个数

这样直接在区间所有信息的集合里面 $\rm{lower\_bound}$

现在的 $[l,r]$ 变成了 $[x,n]$，是线段树射程范围之内

考虑多测的话在线段树上修改就 $\Theta(n)$ 了，一种处理方式是 **对线段树节点长度进行根号分治**

也就是设置一个阀值 $B$，对于那些长度大于 $B$ 的点合并子树信息，查询也是把区间分成 $\rm{len\le B}$ 的区间去做

时间复杂度 $\rm{\Theta(n\sqrt{nlogn})}$

# CF1178F

跟着题面定状态，不管状态多复杂！

- 先考虑弱化版的部分：$1 \sim m$ 是一个排列

	设 $dp[l][r]$ 表示当前区间里面的颜色都合法，也就是已经涂过的颜色段要么在包含要么相离

	转移考虑涂色一定是涂区间里面标号最小的点的颜色，同时区间一定是跨过其位置的

	那么把左边区间可能的凑法和右边可能的凑法求和再乘法即可
    
    时间复杂度 $\Theta(n^3)$

- 如果不是一个排列呢？

	不难发现如果出现的连续段 $\ge\ 2n$ 那么一定无解， 因为一次涂色最多整出来两个分界点
    
    缩段之后照样冲区间 $\rm{DP}$，把所有的当前颜色的的位置，和上面 $\rm{DP}$ 不同的是存一下每个数两个出现点之间的方案数
    
    实现的时候比较奇妙的一点是上来设 `f[i][i-1]=1`
    
# CF1178H

首先把问题转化到 $x=0,x=T$ 两个位置上，这步很好理解，也就是如果满足在交点在 $[0,T]$ 中，那么在 $T$ 也一定满足不等关系

那么每个点能能换的区间在 $0$ 有一些，在 $T$ 有一些，而伴随时间的增长，能交换的对数一定是增多的，那么二分这个 $T$

观察一下这个调换的图，非常像一张二分图，这启示我们使用费用流来解决这个问题

建图就直接能交换的之间连一个 $[inf,1]$ 的边，但是边数是 $n^2$ 的，使用前后缀可以优化

但是每次二分真的都要整网络流吗？不是！

显然我们并不关注每个二分的 $T$ 的代价，那么整个贪心换掉就行了

第一步想到了后面貌似都是常见套路，为啥我第一步都想不到呢？

# NOI2020 制作菜品

这就是所谓思维题吗？我也只好吹爆了

观摩一把数据范围 $m\le n-1,m\le n-2$，这里想想 $m=n-1$ 时有没有什么新意？

如果两个原料做一道菜一定是合法的，对于三个原料做两个菜的情况，使用小于 $k$ 的那个和大于 $k$ 的原料配对，此时问题仍然有解

这东西直接使用 $\rm{set}$ 维护

那么如果 $m>n-1$ 的部分有很多菜的量大于 $k$，那么这时候特判所有菜的量都大于 $n$ 继续做就行

这部分有 $\rm{30pts}$

而剩下的 $m=n-2$ 的部分考虑有样例提示会无解，这 **启示**？如果能分成两个 $[x+y=n],(x,x-1),(y,y-1)$ 的两部分有解，否则无解

那么也就是说是不是存在一个子集的和是 $k$ 的倍数，貌似是 $0/1$ 背包经典题？那么 $\rm{bitset}$ 优化即可

# NOI2019 斗主地

$\rm{30pts}$ 很简单，使用一个朴素的 $\rm{dp[t][i]}$ 表示 $t$ 轮洗牌之后第 $i$ 个位置的答案

注意：$E(i^2)\neq E^2(i)$

考虑设一个 $E_{a,b,x,y}$ 表示局面 $(a,b)$ 变成局面 $(x,y)$ 的概率是 $\frac{a!b!(x+y)!}{(a+b)!x!y!}$ ，这确实是基础计数

猜想这个 $F_{type}(i,k)$ 是关于 $i$ 的 $\rm{type}$ 次函数，伴随 $k$ 的增加始终满足

证明貌似可以强行归纳，可能也是基础计数？？

既然是多项式，直接使用三元一次方程把系数算一把，每次只转移 $3$ 个点处理即可