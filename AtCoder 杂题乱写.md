# AGC020E

固定字符串时可以使用区间 $\rm DP$ 来求解：

设 $f_{l,r}$ 表示对 $[l,r]$ 对应的子串任意操作得到的字符串总方案数，$g_{l,r}$ 表示将区间最外层套上括号的方案数，特殊处理 `g_{i,i}=s[i]+1`

对于 $f$ 的转移，考虑枚举第一段被套上括号的前缀；$g$ 的转移就是考虑周期长度，由于可以嵌套，仍然需要子区间的 $f$ 值来转移。形式化地：

$$\begin{aligned}f_{l,r}&\leftarrow \sum_{i=l}^{r}g_{l,i}f_{i+1,r}\\g_{l,r}&\leftarrow\sum_{d|(r-l+1)}{\huge{[}}\texttt{s[l,l+d-1] is a period of s[l,r]}{\huge{]}}f_{l,l+d-1}\end{aligned}$$

对于全部子集的 $\rm DP$ 类似，设 $f_{S}$ 表示 $S$ 的全部子集的生成子串数量，$g_S$ 是周期划分得到的生成子串数量

转移 $f$ 和上面完全一样，但是转移 $g$ 的时候要对所有段取 $\rm and$ 再调用 $f$

时间复杂度？官方题解里面介绍了一个做法：

>Run your solution on cases of maximum length with different number of ones and see that it is very fast.

一种可能的状态数上界是 $\Theta(2^{12}+n^3)$，并不会证明

# ARC100F

正难则反，用总出现次数 $k^{n-m}\times(n-m+1)$ 来减掉在非合法序列中的出现次数

那么如果给出的序列本来就是合法串那么直接输出，注意这里判断合法与否要逐个区间判定

其余分以下两种情况讨论：

- 序列中的数字可能相同：注意到形成长度为 $k$ 的子段不会跨过给定串，所以分开来前后缀分别处理

    以前缀为例：设给定串最长互不相同前缀的长度为 $l$，那么设 $f_{i,j}$ 表示接到前缀前面的串长度为 $i$ 时，目前极长的互不相同后缀长为 $j$ 的方案数，初态 $f_{0,l}=1$

    转移考虑枚举最后一个位置填什么字符，按照 ACAM 的想法断点可能是 $1\sim j$ 中的某个数字，用前/后缀和优化；新填入数字的方案是 $j-k+1$

    统计结果枚举前缀接上的字符串长度即可

- 如果序列中的数字互不相同：使用上面的方式计算序列数，另开 $g_{i,j}$ 在长度为 $i$ 且目前极长的互不相同后缀长为 $j$ 的情况下，长度为 $m$ 的互不相同数字段 的出现总次数，那么最后统计 $\frac{\sum g_{n,i}}{k^{\underline{m}}}$

    $f$ 的转移同上，根据实际含义，一个位置的出现要乘序列数量是为总出现次数，$g$ 自己转移给自己的情况和 $f$ 同，而互相转移（添加一次出现）的方式是对位做加法

# AGC019F

称还剩 $n$ 个题答案为 Yes，$m$ 个题答案为 No 的为一个局面，记作 $(n,m)$ 

所谓最优策略就是对于任意局面 $(n,m)$，选择较多的一个猜，即 $n\ge m$ 时猜 Yes 否则猜 No

直接根据上述策略计算路径条数即可做到 $\Theta(nm)$ 但是我们并不满足于此（看 Luogu 题解区有直接优化这做法的十分佩服）

使用实际含义考察这个过程，将每个答案排列视作坐标系上的折线，经过的点就是对应的局面，如果有在 $y=x$ 上面的折线部分就翻转下来

那么每种排列都和所选择的策略有 $\max(n,m)$ 段交线，这部分一定在答案里面！其实使用暴力组合式子也可以得到，但是谁会想往这角度推呢？

注意定义中是 $n\ge m$ 就猜 Yes 那么翻转的时候存在漏记，但是只有 $y=x$ 向左的部分会漏记，补加上去即可，增量的计算方法和暴力做法相同

# AGC018E

直观感受就是枚举中转点考虑前面后面方案乘起来，首先处理一个点向一个矩形走的方案数

形式化地讲，即 $(0,0)$ 向矩形 $(x_1,y_1),(x_2,y_2)$ 走的方案数

根据 $\binom {n+1}m=\sum_{i=0}^m\binom{n}i$ 的组合意义，将至推广至二维，先加上走到 $(x_2+1,y_2+1)$ 的方案，那么需要减掉走到 $(x_1,y_2+1)$ 和 $(x_2+1,y_1)$ 的方案

都到这了就不用什么组合意义了，直接拿原恒等式推就能得到少的部分是走到 $(x_1,y_1)$ 的方案

对于在中间矩形中的点，路线必然进出第二矩形，即与第二个矩形的 下左 &  上右 边界相交，所以可以尝试枚举边界上的点对，但是这对复杂度并没有优化

尝试在拆 $\sum$ 的时候最头疼的是变量相乘，但是本题里面的式子并没有这个问题，对于从 $(sx,sy)$ 进,$(ex,ey)$ 出的路线，能选点的个数是 $(ey+ex)-(sx+sy)+2$，这个量可以分开计算

也就是说枚举第二个矩形 上&右 边界上的点，计算其向首尾两个矩形的路径方案，并乘横纵坐标加 $2$ 的结果加入答案，并在答案中减去 下&左 边界上做相同计算得到的结果即可

注意处理第一个矩形时应当对应减一而第三个矩形应加一

# AGC018C

时隔一年，我终于理解这种做法了，简记之

朴素费用流建图即建立三个种类点，连 $\rm (S,A/B/C,x/y/z,0)$，每个元素向 $T$ 连 $(i,T,1,0)$，元素和种类之间的连边费用为权值，暴力最大费用最大流即可

优化即模拟费用流，直接类似于排序维护的做法需要很多的 堆 和 分类讨论，考虑一种快速找到增广路的做法：

对于还没去满的种类 $S$ 向其连边，边权为 $0$；每个种类向 $T$ 连边，边权为没有钦定种类的元素中该种类价值最大的元素，表示该直接选，不进行替换

种类之间连边，以 $B\to A$ 为例，表示种类 $A$ 中一个元素换成种类 $B$ 而 $A$ 再另取，有向边的方向可以通过考察 EK 过程得到，边权是 $\max_{x\in A} B_x-A_x $，正确性来源于 EK 保证了每个被选中的元素不会被退选同时增广路也不会重复经过点

找到边权可以使用堆进行维护，复杂度 $\Theta(nk^2\log n)$，建出的 $\Theta(k)$ 的图上面跑最长路作为增广结果加入答案，并根据增广路进行更新

需要改的是种类的剩余数量和种类之间的堆，根据 $\rm S\to A/B/C$ 的终点更新未选的元素对应的堆


# ARC107F

尝试改变对绝对值求和的表达式，设 $\rm P=\sum\limits_{b_i\ge 0} b_i,N=\sum\limits_{b_i\le 0} b_i$ 分别表示正负值的和，所以绝对值之和是 $\rm N+P-2\min(N,P)$

由题设我们还需要减去没有被选择的点的 $\sum a$，所以现在问题转化为最小化这两者的和，尝试使用网络流来解决这个问题，**两者取 $\min$ 可以通过正数连 $S$ 负数连 $T$ 来表示**

因为是在无向图上连边，所以拆点，**再将无向图上的 $(u,v)$ 表示为网络流图上的 $(u',v,+\infty ),(v',u,+\infty)$ 来表示连通性**

题目展现出了最小割的端倪：割掉左侧/右侧的边就表示将其选入 $\rm N/P$，如果一个连通块向源汇点的边不删完就还能走流量

那么最后在图上表示出删掉某个点：在 $(u,u')$ 之间连接一条容量为 $a_i+|b_i|$ 的边，注意删掉一个点之后它就不能在 $\rm N/P$ 中贡献了

这部分不再另外向 $S/T$ 中连 $+\infty$ 边了？因为是最小化两部分的和，所以不另外连边就可以达到**互相限制**的效果

这图还是很精彩的，很有收获的一题 ~~背过待用.jpg~~

# AGC050C

观察操作形式，设 $(a,b)$ 表示对手两侧（可以交换顺序）还剩下多少格子可以走，初始状态 $(+\infty ,+\infty)$

玩家的操作是让对手的状态由 $(a,b)$ 变成 $(\min(a,b),0)$

那么你手上的操作多于 $\log$ 次那么一定可以让对方死掉，因为每次操作必然让最开始的 $a+b$ 减少 $\frac1 2$

那么设 $dp_{i,j}$ 表示操作完成了 $[i,n]$，你还需要 $j$ 操作才能让对方输（或者对方还有 $2^j$ 个格子能走） 的方案数 

转移考虑如果这个操作可以不由对方执行，那么转移给 $dp_{i-2^j-1,j+1}$ 因为对手需要走这么多步来达到当前的 $dp_{i,j}$ 

而这里需要注意的是这个转移要满足前面 $2^j$ 个中没有玩家的必操作步

而如果这个操作可以由对手进行的话直接当作废步转移给 $dp_{i-1,j}$，因为有用的步都在上面转移了，对手剩余的回合最好选择呆在区间中点一动不动

# ARC087F

考察这个限制：发现对于一条边而言，使其经过最多次数一定是让 $(i,p_i)$ 尽量处于边的两侧，贡献是 $\min(siz_u,n-siz_u)$

回到全局角度最大化该式子的和值就是找到重心，$(i,p_i)$ 分别处于重心的两个不同子树之中

然而直接统计排列很困难所以考虑减去不合法方案数，设 $dp_i$ 表示钦定 $i$ 个位置的 $p_i$ 和自己是一个子树里面的

对于某个子树的 $dp_i=\binom {siz}i^2 i!$，这里前面是选择 $i$ 和 $p_i$ 的方案，后面因为这些 $p_i$ 可以乱放所以要乘阶乘

枚举重心的所有子树进行背包即可完成统计

每个 $dp_i$ 在完成钦定之后剩下的位置可以随便放 $p_i$，要乘 $(n-i)!$，最后附加上 $(-1)^i$ 作为容斥系数即可

---

博主学了三四年OI并不理解基础容斥式子，下简记

考察有 $k$ 个错误位置的排列在答案中的计算次数，它会在每个 $dp_i\times (n-i)!$ 中计算 $\binom ki$ 次

再不会容斥基础组合恒等式还是会的，所以就正确了

# AGC052B

考虑该操作的本质：如果以 $1$ 为根进行 $\rm{DFS}$，将根到某点路径上的每个边的异或和作为该点的权值，那么对于和根不相连的点，操作一条边可以视作点权交换

设 $a_x$ 表示用 $w_1$ 作为边权的时候的点权，$b_x$ 表示用 $w_2$ 作边权的时候的点权

但是这样的思路明显有限制：和根相连的边在操作的时候并不能用点权交换的方法表示

那么建立一个虚根和 $1$ 相连，如果能找到一个根和 $1$ 连边的边权 $W$ 满足 $a_x\oplus W=b_y$ 且 $x,y$ 两两配对那么满足条件

由于 $n$ 是奇数，将所有的上述对应式子异或起来之后发现 $W=\rm{xor}_ {i=1}^n x_i\oplus y_i$

得到 $W$ 之后判断是不是 $\{a_i\oplus W\}$ 和 $\{b_i\}$ 相等即可

# AGC004F

原来 CF1615F 的染色是常见套路

考察树的部分，将深度为偶数的点颜色取反，此时原操作变成交换相邻的 取反点 与 非取反点，最终的目的是将取反点点全放到 非取反点 处，非取反点 都到 取反点 处，此时再将深度为偶数的点取反就可以完成题设

剩下考虑每条边的经过次数，也就是子树里面黑点白点数量差的绝对值，设其为 $a_i$，因为这些点需要从子树外运进来，形式化的就是 $\sum |a_i|$

判断 $-1$ 的条件是 $a_{root}=0$，让黑白点数相同

基环树的部分先建立 dfs 树，将图上的环变成根链，观察树上取反操作本质是二分图染色

先考察不能二分图染色的奇环基环树，此时操作反祖边可以 增加/减少 取反点数量，需要增加的取反点数量是 $\frac{|a_{root}|}2$，这些点会对环上 $a_i$ 带来的影响就是链上 $a_i$ 均增加之，计算答案的方式不变

最后是可以二分图染色的偶环基环树，此时由于黑白点的数量固定，所以还是需要判断 $a_{root}=0$，上面的包判断 $a_{root}\equiv 0 \bmod 2$ 即可

计算出初始的子树 $a$ 之后使用环上的边进行点的运输，将边上运输的点量设为 $x_i$ 并都使用返祖边对应的未知数表示，发现问题中所谓最小化 $\sum |x_i|$ 就是找中位数，变化量就容易得到了！